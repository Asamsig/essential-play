## Handling Failure

We've now seen everything we need to read and write arbitrary JSON data. We are almost ready to create full-featured JSON REST APIs. There's only one more thing we need to cover: failure.

When a JSON REST endpoint fails, it needs to return JSON to the client. We can do this manually in the case of expected errors, but what about unexpected errors such as exceptions?

In this section we will look at replacing Play's default 400 and 500 error pages with our own JSON error pages. We'll do this by writing some simple error handlers using Play's `Global` object.

### The *Global* Object

We can configure various HTTP-handling aspects of our applications by creating an object called `Global` in the `_root_` package. The object should extend [`play.api.GlobalSettings`], which provides various methods to override:

~~~ scala
package _root_

import play.api._

object Global extends GlobalSettings {
  // custom configuration goes here...
}
~~~

### Custom Routing Error Pages

The default routing error page is provided by the `onHandlerNotFound` method. We can override this to return whatever `Content-Type` we like---here's an example that returns JSON for the client to interpret:

~~~ scala
import play.api.libs.json._
import scala.concurrent.Future

object Global extends GlobalSettings {
  override def onHandlerNotFound(request: RequestHeader): ↩
        Future[Result] = {
    Logger.warn(s"Error 404: ${request.method} ${request.uri}")

    Future.successful(NotFound(Json.obj(
      "type"    -> "error",
      "status"  -> 404,
      "message" -> s"Handler not found: ${request.method} ${request.uri}"
    )))
  }
}
~~~

Note that the method accepts a `RequestHeader` and returns a `Future[Result]`. The `RequestHeader` type indicates that the body of the request may not yet have been read. The `Future` return type allows us to execute asynchronous code before returning a `Result`---we will see this in more detail in the next chapter.

We can also provide a custom response when Play is able to route a request but is unable to parse the URL parameters:

~~~ scala
object Global extends GlobalSettings {
  override def onBadRequest(request: RequestHeader): ↩
        Future[Result] = {
    Logger.warn(s"Error 404: ${request.method} ${request.uri}")

    Future.successful(BadRequest(Json.obj(
      "type"    -> "error",
      "status"  -> 400,
      "message" -> s"Bad request data: ${request.method} ${request.uri}"
    )))
  }
}
~~~

### Custom Application Error Pages

The default exception page is generated by the `onError` method. Again, we can override this method to provide our own behaviour. Note that in this case the method does not return a `Future`:

~~~ scala
object Global extends GlobalSettings {
  override def onError(request: RequestHeader, exn: Throwable) = {
    Logger.warn(s"Error 500: ${exn.getMessage}", exn)

    InternalServerError(Json.obj(
      "type"    -> "error",
      "status"  -> 500,
      "message" -> exn.getMessage
    ))
  }
}
~~~

### Other Methods

`GlobalSettings` contains some other useful methods not covered above:

 - `onStart` allows us to hook into the application's startup process;
 - `onStop` allows us to hook into the application's shutdown process;
 - `doFilter` allows us to provide custom HTTP filters, for example adding JSONP, logging, or CORS support to every request.

### Take Home Points

We can customise various aspects of our application's general behaviour by providing a `_root_.Global` object. The object must extend [`play.api.GlobalSettings`].

`GlobalSettings` contains several methods that we can override to custom error responses:

 - `onHandlerNotFound` allows us to customise responses when Play cannot route a request;
 - `onBadRequest` allows us to customise responses when Play cannot extract URL parameters;
 - `onError` allows us to customise responses triggered by unhandled exceptions.

---
layout: page
title: Formats for type hierarchies
---

# Formats for type hierarchies

In this final section, we cover a specific use-case that comes up often when writing JSON serialization -- how to write `Formats` for generalised hierarchies of types.

## *OFormats* and *OWrites*

To understand this approach, we need to understand two final members of Play's pantheon of reader and writer types. [play.api.libs.json.OWrites] and [play.api.libs.json.OFormat] representing `Writes` and `Formats` that serialize data to instances of `JsObject`:

~~~ scala
package play.api.libs.json

trait OWrites[-A] extends Writes[A] {
  def writes(value: A): JsObject
}

trait OFormat[A] extends Reads[A] with OWrites[A]
~~~


The objects generated by `Json.writes` and `Json.format` are actually `OWrites` and `OFormats` respectively -- their `writes` methods have the return type `JsObject` rather than `JsValue`.

Why is this useful? If know that serializing a data type to JSON will result in a `JsObject`, we gain access to additional methods that we can use to manipulate and append fields to the object. For example:

~~~ scala
addressFormat.writes(Address(29, "Acacia Road")) ++ Json.obj("city" -> "Nuttytown")
// == Json.obj("number" -> 29, "street" -> "Acacia Road", "city" -> "Nuttytown")
~~~

## Typing the untyped

We can use the technique described above of to append a `"type"` field to our JSON to retain type information while the data is on the client. We can use the `"type"` field when we read JSON from a `Request` to decide which `Reads` to use to parse the data.

Let's see this in action for a simple type hierarchy:

~~~ scala
sealed trait Animal
case class Cat(cheezburgers: Int)  extends Animal
case class Dog(hotdogs: Int)       extends Animal
case class Flamingo(pink: Boolean) extends Animal
~~~

We begin by defining `Formats` for each subtype:

~~~ scala
import play.api.libs.json._
import play.api.data.validation.ValidationError

implicit val catFormat      = Json.format[Cat]
implicit val dogFormat      = Json.format[Dog]
implicit val flamingoFormat = Json.format[Flamingo]
~~~

We can combine these formats to produce a format for the supertype as follows:

~~~ scala
implicit object animalFormat extends Format[Animal] {
  private def writeObject[A](value: A)(implicit valueWrites: OWrites[A]): JsObject =
    valueWrites.writes(value)

  def writes(animal: Animal): JsValue = animal match {
    case animal: Cat      => catFormat.writes(animal)      ++ Json.obj("type" -> "Cat")
    case animal: Dog      => dogFormat.writes(animal)      ++ Json.obj("type" -> "Dog")
    case animal: Flamingo => flamingoFormat.writes(animal) ++ Json.obj("type" -> "Flamingo")
  }

  def reads(json: JsValue): JsResult[Animal] = (json \ "type") match {
    case JsString("Cat")      => catFormat.reads(json)
    case JsString("Dog")      => dogFormat.reads(json)
    case JsString("Flamingo") => flamingoFormat.reads(json)
    case other => JsError(JsPath \ "type", ValidationError("error.invalid.animal.type", other))
  }
}
~~~

The `writes` method uses the subtype formats to convert the parameter to a `JsObject` and append a `"type"` field. Conversely, the `reads` method inspects the `"type"` field and uses its value to dispatch the JSON to the relevant subtype format.

## Take home points

TODO

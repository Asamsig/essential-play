## Custom Formats: Part 3

In this final section, we cover a common use-case -- creating `Reads`, `Writes`, and `Formats` for generalised hierarchies of types.

### *OFormats* and *OWrites*

Before introducing this example, we need to look at two final members of Play's pantheon of readers and writers:

[play.api.libs.json.OWrites] and [play.api.libs.json.OFormat] are specialisations of `Writes` and `Formats` that return `JsObjects` instead of `JsValues`. The objects generated by `Json.writes` and `Json.format` are actually of these types:

~~~ scala
package play.api.libs.json

trait OWrites[-A] extends Writes[A] {
  def writes(value: A): JsObject
}

trait OFormat[A] extends Reads[A] with OWrites[A]
~~~

`JsObject` contains methods that let us manipulate fields. The `+` and `++` methods, in particular, allow us to append fields to the JSON we send to clients:

~~~ scala
addressFormat.writes(Address(29, "Acacia Road")) ++
  Json.obj("city" -> "Nuttytown")
// => Json.obj(
//   "number" -> 29,
//   "street" -> "Acacia Road",
//   "city" -> "Nuttytown"
// )
~~~


### Handling Type Hierarchies

Until now we have written `Reads` and `Writes` that deal exclusively with one type of data. What do we do when we need to serialize a *set* of possible types? Consider the following type hierarchy:

~~~ scala
sealed trait Shape
case class Ellipse(width: Int, height: Int) extends Shape
case class Rectangle(width: Int, height: Int) extends Shape
~~~

We can *write* each of these types as a JSON object with two fields: `"width"` and `"height"`. However, when it comes to *reading* JSON we have a problem: we no longer know what type of shape we're dealing with.

We can solve this problem by adding the type information to the JSON as *metadata*. For example, we can add a `"type"` field with value `"Ellipse"` or `"Rectangle"` to indicate the type of shape.

Let's see this in action. We begin by defining `Formats` for each subtype:

~~~ scala
import play.api.libs.json._
import play.api.data.validation.ValidationError

implicit val ellipseFormat   = Json.format[Ellipse]
implicit val rectangleFormat = Json.format[Rectangle]
~~~

We write a `Format` for `Shape` that adds in the `"type"` field. We delegate to `ellipseFormat` and `rectangleFormat` using pattern matching:

~~~ scala
implicit object shapeFormat extends Format[Shape] {
  def writes(shape: Shape): JsValue = shape match {
    case shape: Ellipse =>
      ellipseFormat.writes(shape) ++ Json.obj("type" -> "Ellipse")

    case shape: Rectangle =>
      rectangleFormat.writes(shape) ++ Json.obj("type" -> "Rectangle")
  }

  def reads(json: JsValue): JsResult[Shape] = (json \ "type") match {
    case JsString("Ellipse")   => ellipseFormat.reads(json)
    case JsString("Rectangle") => rectangleFormat.reads(json)
    case other =>
      JsError(JsPath \ "type", "bad.shape.type", other.toString)
  }
}
~~~

Because `ellipseFormat` and `rectangleFormat` are `OWrites`, they return `JsObjects` instead of `JsValues`. We use this fact in our `writes` method to append the `"type"` field.

Our `reads` method inspects the `"type"` field and delegates to `ellipseFormat` or `rectangleFormat` appropriately. If the type isn't one of the expected values, we fail with an appropriately pathed `JsError`.

### Take Home Points

In this section we created a JSON format for a simple type hierarchy. This is a common use case for hand-written formats.

We used a hand-written `Format` to add type metadata to the JSON in the form of a `"type"` field. We made use of existing macro-defined JSON formats to do the majority of the work.

Macro-defined `Writes` and `Formats` always create `JsObjects`. For convenience, Play provides two subtypes, `OWrites` and `OFormat`, that tighten the return type on the `writes` method accordingly. We used this in our hand-written `Format` to add the `"type"` field to the outgoing JSON.

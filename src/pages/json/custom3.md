## Custom Formats: Part 3

In this final section, we cover a common use-case---creating `Reads`, `Writes`, and `Formats` for generalised hierarchies of types.

### *OFormats* and *OWrites*

Before introducing this example, we need to look at two final members of Play's pantheon of readers and writers:

[`play.api.libs.json.OWrites`] and [`play.api.libs.json.OFormat`] are specialisations of `Writes` and `Formats` that return `JsObjects` instead of `JsValues`:

~~~ scala
package play.api.libs.json

trait OWrites[A] extends Writes[A] {
  def writes(value: A): JsObject
}

trait OFormat[A] extends Reads[A] with OWrites[A]
~~~

`JsObject` contains methods that let us manipulate fields. The `+` and `++` methods, in particular, allow us to append fields to the JSON we send to clients. This is useful for tweaking the JSON data we're reading and writing as we shall see below:

~~~ scala
// The + method adds fields to a JsObject:
Json.obj("a" -> 1) + ("b" -> JsNumber(2))
// res0: play.api.libs.json.JsObject = {"a":1,"b":2}

// The ++ methods combines the fields of two JsObjects:
Json.obj("a" -> 1) ++ Json.obj("b" -> 2)
// res1: play.api.libs.json.JsObject = {"a":1,"b":2}
~~~

The `Writes` and `Formats` generated by `Json.writes` and `Json.format` are actually `OWrites` and `OFormats`, so we can take advantage of this functionality out of the box:

~~~ scala
addressFormat.writes(Address(29, "Acacia Road")) ++
  Json.obj("city" -> "Nuttytown")
// res0: JsObject = JsObject(
//   ("number", JsNumber(29)),
//   ("street", JsString("Acacia Road")),
//   ("city", JsString("Nuttytown")))
~~~

### Handling Type Hierarchies

Until now we have written `Reads` and `Writes` that deal exclusively with one type of data. What do we do when we need to serialize a *set* of possible types? Consider the following type hierarchy:

~~~ scala
sealed trait Shape
case class Ellipse(width: Int, height: Int) extends Shape
case class Rectangle(width: Int, height: Int) extends Shape
~~~

We can *write* each of these types as a JSON object with two fields: `"width"` and `"height"`. However, when it comes to *reading* JSON we have a problem: we no longer know what type of shape we're dealing with.

We can solve this problem by adding the type information to the JSON as metadata. For example, we can add a `"type"` field with value `"Ellipse"` or `"Rectangle"` to indicate the type of shape.

Let's see this in action. We begin by defining `Formats` for each subtype:

~~~ scala
import play.api.libs.json._
import play.api.data.validation.ValidationError

implicit val ellipseFormat   = Json.format[Ellipse]
implicit val rectangleFormat = Json.format[Rectangle]
~~~

We then write a `Format` for `Shape` that adds in the `"type"` field. We delegate to `ellipseFormat` and `rectangleFormat` using pattern matching:

~~~ scala
implicit object shapeFormat extends Format[Shape] {
  def writes(shape: Shape): JsValue = shape match {
    case shape: Ellipse =>
      ellipseFormat.writes(shape) ++ Json.obj("type" -> "Ellipse")

    case shape: Rectangle =>
      rectangleFormat.writes(shape) ++ Json.obj("type" -> "Rectangle")
  }

  def reads(json: JsValue): JsResult[Shape] = (json \ "type") match {
    case JsString("Ellipse")   => ellipseFormat.reads(json)
    case JsString("Rectangle") => rectangleFormat.reads(json)
    case other =>
      JsError(JsPath \ "type", "bad.shape.type", other.toString)
  }
}
~~~

Because `ellipseFormat` and `rectangleFormat` are `OWrites`, they return `JsObjects` instead of `JsValues`. We use this fact in our `writes` method to append the `"type"` field.

Our `reads` method inspects the `"type"` field and delegates to `ellipseFormat` or `rectangleFormat` appropriately. If the type isn't one of the expected values, we fail with an appropriately pathed `JsError`.

We can use this technique to create `Reads`, `Writes`, and `Formats` for arbitrary hierarchies of case classes and sealed traits, allowing us to serialize any data we care to imagine as JSON.

### Take Home Points

In this section we created a JSON format for a simple type hierarchy. This is a common use case for hand-written `Formats` as Play does not provide this functionality out-of-the-box.

We used a hand-written `Format` to add type metadata to the JSON in the form of a `"type"` field. We made use of existing macro-defined JSON formats to do the majority of the work.

Macro-defined `Writes` and `Formats` always create `JsObjects`. For convenience, Play provides two subtypes, `OWrites` and `OFormat`, that tighten the return type on the `writes` method accordingly. We used this in our hand-written `Format` to add the `"type"` field to the outgoing JSON.

### Exercise: Stable Codebase

The `chapter4-animals` directory in the exercises
contains an `Animal` type and subtypes.

Write a JSON format for `Animal` using the techniques described above.
Write the classname to the JSON as a field called `"type"`
and use this field to determine which type to parse on read.
If the user specifies an invalid `"type"`,
fail with the error `"error.expected.animal.type"`.

Ensure your format passes the unit tests provided.
Don't alter the tests in any way!

<div class="solution">
The simplest solution involves using Play's JSON macros
to (de)serialize `Dog`, `Insect`, and `Swallow`,
and a custom format to handle the `"type"` parameter:

~~~ scala
val dogFormat     = Json.format[Dog]
val insectFormat  = Json.format[Insect]
val swallowFormat = Json.format[Swallow]

implicit object AnimalFormat extends Format[Animal] {
  def reads(in: JsValue) = (in \ "type") match {
    case JsString("Dog")     => dogFormat.reads(in)
    case JsString("Insect")  => insectFormat.reads(in)
    case JsString("Swallow") => swallowFormat.reads(in)
    case _ => JsError(JsPath \ "type", "error.expected.animal.type")
  }

  def writes(in: Animal) = in match {
    case in: Dog     => dogFormat.writes(in)     ++ Json.obj("type" -> "Dog")
    case in: Insect  => insectFormat.writes(in)  ++ Json.obj("type" -> "Insect")
    case in: Swallow => swallowFormat.writes(in) ++ Json.obj("type" -> "Swallow")
  }
}
~~~
</div>

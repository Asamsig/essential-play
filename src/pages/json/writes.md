## Writing JSON

The application code in a typical REST API operates on a domain model consisting of sealed traits and case classes.
When we have finished an operation, we have to take the result, convert it to JSON, and wrap it in a Result to send it to the client.

### Meet *Writes*

We convert Scala values to JSON using the [`play.api.libs.json.Writes`] trait:

~~~ scala
trait Writes[A] {
  def writes(value: A): JsValue
}
~~~

Play provides built-in `Writes` for many standard data types, and we can create `Writes` by hand for any data type we want to serialize.

Play also provides a simple one-liner of defining a `Writes` for a case class:

~~~ scala
case class Address(number: Int, street: String)

val addressWrites: Writes[Address] = Json.writes[Address]
~~~

`Json.writes` is a *macro* that inspects the `Address` type and generates code to define a sensible `Writes`. The macro saves us some typing but it only works on case classes. We'll see how to define `Writes` by hand later on.

`addressWrites` is an object that can serialize an `Address` to a `JsObject` with sensible field names and values:

~~~ scala
// Create an address:
val address = Address(29, "Acacia Road")

// Convert it to JSON:
val json: JsValue = addressWrites.writes(address)
// json: JsValue = Json.obj("number" -> 29, "street" -> "Acacia Road")
~~~

### Implicit *Writes*

Let's look at a more complicated example---what happens when we try to define a `Writes` for a nested data structure?

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

val personFormat = Json.writes[Person]
// compile error: No implicit format for Address available
~~~

The object generated by `Json.writes` assumes that there is an implicit `Writes` available for each field in the type being written:

 - the `Writes` for `Address` requires implicit `Writes` for `Int` and `String`;
 - the `Writes` for `Person` requires implicit `Writes` for `String` and `Address`.

Play defines built-in `Writes` instances for common data types like `Int` and `String` (see [`play.api.libs.json.DefaultWrites`] for details), but there is no predefined implicit `Writes` for `Address`. We need to define this ourselves and make it available as an implicit value:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
val personWrites = Json.writes[Person]
// personWrites: play.api.libs.json.OWrites[Person] = ...
~~~

### The *Json.toJson* Method

We can use our new `personWrites` to serialize data just as we did with `addressWrites`:

~~~ scala
val json: JsValue = personWrites.writes( ↩
  Person("Eric Wimp", Address(29, "Acacia Road")))
// json: JsValue = JsObject(List( ↩
//   ("name", JsString("Eric Wimp")), ↩
//   ("street", JsObject(List( ↩
//     ("number", JsNumber(29)), ↩
//     ("street", JsString("Acacia Road")))))))
~~~

However, using different `Writes` objects to serialize each type in our application is inconvenient---we have to remember the variable name for each `Writes` and we can't write generic code to abstract over serializable data types.

Fortunately, Play provides the `Json.toJson` method, which accepts a value of type `A` and an implicit parameter of type `Writes[A]`. Here's the implementation:

~~~ scala
package play.api.libs.json

object Json {
  // ...

  def toJson[A](value: A)(implicit w: Writes[A]): JsValue =
    w.writes(value)

  // ...
}
~~~

Using this method we can serialize any data type as long as there is an appropriate `implicit` `Writes` in scope:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
implicit val personWrites  = Json.writes[Person]

Json.toJson(Address(29, "Acacia Road"))
// res0: play.api.libs.json.JsValue = ↩
//   {"number":29,"street":"Acacia Road"}

Json.toJson(Person("Eric Wimp", Address(29, "Acacia Road")))
// res1: play.api.libs.json.JsValue = ↩
//   {"name":"Eric Wimp","address":{"number":29,"street":"Acacia Road"}}

def genericOkResult[A](value: A)(implicit valueWrites: Writes[A]): Result =
  Ok(Json.toJson(value))

genericOkResult(Address(29, "Acacia Road"))
// res2: play.api.mvc.Result = ↩
//   Ok({"number":29,"street":"Acacia Road"})
~~~

Veterans of *Underscore's Essential Scala* will recognise this as the *type class pattern*!

<div class="callout callout-info">
*Writes Best Practices*

Because `Writes` is a type class, we can conveniently apply the *type class pattern* to our web applications:

 - Define our data model as a set of case classes to take advantage of the `Json.writes` macro.
 - Define an `implicit` `Writes` in the companion object for each case class.
 - Use `Json.toJson` to serialize data as JSON.
 - Use implicit parameters (or context bounds) wherever we want to write code to serialize arbitrary types.
</div>

### Take Home Points

We convert Scala data to JSON using instances of [`play.api.libs.json.Writes`].

Play provides a convenient macro, `Json.writes`, to define a `Writes` for case classes. If we're not dealing with case classes, we have to create `Writes` by hand. We'll cover hand-written *Writes* in detail later on.

We can use the `Json.toJson` method to serialize any data type for which we have an `implicit` `Writes` in scope. We therefore typically define `Writes` in companion objects or singleton library object, and bring them into scope wherever we need them to create a JSON `Result`.

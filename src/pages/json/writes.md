---
layout: page
title: Writing JSON
---

# Writing JSON

In a typical JSON web service, most of our business logic will involve operations on a *domain model* consisting of sealed traits, case classes, and case objects. When we send data to a client in a `Result`, we must convert that data to JSON.

## Meet *Writes*

We implement conversions from Scala data to JSON using instances of the [play.api.libs.json.Writes] trait:

~~~ scala
trait Writes[A] {
  def writes(value: A): JsValue
}
~~~

Play provides a trivial way of defining a `Writes` for any case class in our data model:

~~~ scala
case class Address(number: Int, street: String)

val addressWrites: Writes[Address] = Json.writes[Address]
~~~

`Json.writes` is actually a macro that inspects the `Address` type and generates code to define a sensible `Writes`. The macro only works on case classes, but all it does is save us some typing -- we'll see how to define `Writes` by hand later on.

The result, `addressWrites`, is an object that can serialize an `Address` to a `JsObject` with sensible field names and values:

~~~ scala
// Create an address:
val address = Address(29, "Acacia Road")

// Convert it to JSON:
val json: JsValue = addressWrites.writes(address)

// The end result is as follows:
assert(json == Json.obj("number" -> 29, "street" -> "Acacia Road"))
~~~

## Implicit Writes

Let's look at a more complicated example -- what happens when we try to define a `Writes` for a nested data structure?

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

val personFormat  = Json.writes[Person] // does not compile
~~~

If we try to compile this code, we will an error on the the last line:

~~~
error: No implicit format for Address available.
~~~

The object generated by `Json.writes` assumes that there is an implicit `Writes` available for each field in the type:

 - the `Writes` for `Address` requires implicit `Writes` for `Int` and `String`;
 - the `Writes` for `Person` requires implicit `Writes` for `String` and `Address`.

Our example for `Address` worked fine because Play defines built-in `Writes` instances for common data types like `Int` and `String` (see [play.api.libs.json.DefaultWrites] for details). To implement `Writes[Person]` we need to make an instance of `Writes[Address]` available as an implicit value:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
val personWrites = Json.writes[Person] // now it compiles!
~~~

[play.api.libs.json.DefaultWrites]: https://playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.json.DefaultWrites

## The *Json.toJson* Method

We can use our new `personWrites` to serialize data just as we did with `addressWrites`:

~~~ scala
val json: JsValue = personWrites.writes(Person("Eric Wimp", Address(29, "Acacia Road")))
~~~

However, using different `Writes` objects to serialize each type in our application is inconvenient -- it requires us to remember a lot of different identifiers, and it prevents us writing generic code that can serialize data of multiple different type.

Enter the `Json.toJson` method, which solves this problem by accepting a parameter and implicitly locating a `Writes` of the relevant type. Here's the implementation:

~~~ scala
package play.api.libs.json

object Json {
  // ...

  def toJson[A](value: A)(implicit valueWrites: Writes[A]): JsValue =
    valueWrites.writes(value)

  // ...
}
~~~

Using this method we can serialize any value for which we have an implicitly available `Writes`:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
implicit val personWrites  = Json.writes[Person]

// This compiles because we have a `Writes[Address]` in scope:
Json.toJson(Address(29, "Acacia Road"))

// This compiles because we have a `Writes[Person]` in scope:
Json.toJson(Person("Eric Wimp", Address(29, "Acacia Road")))

// This generic method can be used for any type with a corresponding `Writes`:
def genericOkResult[A](value: A)(implicit valueWrites: Writes): Result =
  Ok(Json.toJson(value))

// Example use case for `genericOkResult`:
genericOkResult(Address(29, "Acacia Road"))
~~~

Veterans of *Underscore's Essential Scala* course will recognise this as the stalwart *type class pattern*!

<div class="callout callout-info">
#### *Writes* Best Practices

Now that we know `Writes` is a type class, we can apply the type class pattern to our web applications:

 - Define a set of data types. Use case classes wherever possible to take advantage of the `Json.writes` macro.
 - Define an implicit `Writes` instance in the companion object for each type.
 - Use `Json.toJson` to serialize any data as JSON.
 - Use implicit parameters (or context bounds) to write generic code that handles a variety of data types.
</div>

## Take Home Points

TODO

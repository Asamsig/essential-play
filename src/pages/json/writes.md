---
layout: page
title: Writing JSON
---

# Writing JSON

The application code in a typical REST API operates on a domain model consisting of sealed traits and case classes.
When we have finished an operation, we have to take the result, convert it to JSON, and wrap it in a Result to send it to the client.

## Meet *Writes*

We convert Scala values to JSON using the [play.api.libs.json.Writes] trait:

~~~ scala
trait Writes[A] {
  def writes(value: A): JsValue
}
~~~

Play provides built-in `Writes` for many standard data types, and we can create `Writes` by hand for any data type we want to serialize.

Play also provides a simple one-liner of defining a `Writes` for a case class:

~~~ scala
case class Address(number: Int, street: String)

val addressWrites: Writes[Address] = Json.writes[Address]
~~~

`Json.writes` is a *macro* that inspects the `Address` type and generates code to define a sensible `Writes`. The macro saves us some typing but it only works on case classes. We'll see how to define `Writes` by hand later on.

`addressWrites` is an object that can serialize an `Address` to a `JsObject` with sensible field names and values:

~~~ scala
// Create an address:
val address = Address(29, "Acacia Road")

// Convert it to JSON:
val json: JsValue = addressWrites.writes(address)

// The end result is as follows:
assert(json == Json.obj("number" -> 29, "street" -> "Acacia Road"))
~~~

[play.api.libs.json.Writes]: https://playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.json.Writes

## Implicit Writes

Let's look at a more complicated example -- what happens when we try to define a `Writes` for a nested data structure?

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

val personFormat = Json.writes[Person] // does not compile
~~~

If we try to compile this code we get an error on the the last line:

~~~
error: No implicit format for Address available.
~~~

The object generated by `Json.writes` assumes that there is an implicit `Writes` available for each field in the type:

 - the `Writes` for `Address` requires implicit `Writes` for `Int` and `String`;
 - the `Writes` for `Person` requires implicit `Writes` for `String` and `Address`.

Play defines built-in `Writes` instances for common data types like `Int` and `String` (see [play.api.libs.json.DefaultWrites](https://playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.json.DefaultWrites)] for details), but there is no predefined implicit `Writes` for `Address`. We need to define this ourselves and make it available as an implicit value:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
val personWrites = Json.writes[Person] // now this compiles!
~~~

## The *Json.toJson* Method

We can use our new `personWrites` to serialize data just as we did with `addressWrites`:

~~~ scala
val json: JsValue = personWrites.writes(Person("Eric Wimp", Address(29, "Acacia Road")))
~~~

However, using different `Writes` objects to serialize each type in our application is inconvenient -- we have to remember a lot of different identifiers, and we can't write generic code to serialize data of an arbitrary type.

Fortunately, Play provides the `Json.toJson` method, which accepts a value of type `A` and an implicit parameter of type `Writes[A]`. Here's the implementation:

~~~ scala
package play.api.libs.json

object Json {
  // ...

  def toJson[A](value: A)(implicit w: Writes[A]): JsValue =
    w.writes(value)

  // ...
}
~~~

Using this method we can serialize any data type as long as there is an appropriate `implicit` `Writes` in scope:

~~~ scala
case class Address(number: Int, street: String)
case class Person(name: String, address: Address)

implicit val addressWrites = Json.writes[Address]
implicit val personWrites  = Json.writes[Person]

// This compiles because we have a `Writes[Address]` in scope:
Json.toJson(Address(29, "Acacia Road"))

// This compiles because we have a `Writes[Person]` in scope:
Json.toJson(Person("Eric Wimp", Address(29, "Acacia Road")))

// This generic method can be used for any type with a corresponding `Writes`:
def genericOkResult[A](value: A)(implicit valueWrites: Writes): Result =
  Ok(Json.toJson(value))

// Example use case for `genericOkResult`:
genericOkResult(Address(29, "Acacia Road"))
~~~

Veterans of *Underscore's Essential Scala* course will recognise this as the *type class pattern*!

<div class="callout callout-info">
#### Summary: *Writes* Best Practices

Because `Writes` is a type class, we can conveniently apply the *type class pattern* to our web applications:

 - Define our data model as a set of case classes to take advantage of the `Json.writes` macro.
 - Define an `implicit` `Writes` in the companion object for each case class.
 - Use `Json.toJson` to serialize data as JSON.
 - Use implicit parameters (or context bounds) wherever we want to write code to serialize arbitrary types.
</div>

## Take Home Points

We convert Scala data to JSON using instances of [play.api.libs.json.Writes].

Play provides a convenient macro, `Json.writes`, to define a `Writes` for case classes. If we're not dealing with case classes, we have to create `Writes` by hand.

We can use the `Json.toJson` method to serialize any data type for which we have an `implicit` `Writes` in scope. We therefore typically define `Writes` in companion objects or singleton objects, and bring them into scope wherever we need them to create `Results`.

[play.api.libs.json.Writes]: https://playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.json.Writes
